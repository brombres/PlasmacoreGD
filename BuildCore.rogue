# To run this build file, install Rogue from github.com/brombres/Rogue then cd
# to this folder and type "rogo" at the command line, or "rogo help" for a list
# of supported commands.

$requireRogue "2.18"

uses Math/Best
uses Utility/GitIgnorePatcher
uses Utility/VersionNumber

augment Build
  # You can create a Local.rogo file with overrides for these values, e.g.:
  #   AUTOLAUNCH = "path/to/project/folder"
  PROPERTIES
    AUTOLAUNCH        = ""  # Godot project path to auto-launch after a default 'rogo' build.
    GODOT_EXE_MACOS   = ""
    GODOT_EXE_WINDOWS = ""
    GODOT_EXE_LINUX   = ""

    GODOT_CPP_BRANCH = "4.1"
endAugment

routine rogo_default
  # Builds the extension for the current platform's default architecture.
  if (File("Source").exists)
    if (File("Source").listing("*.cpp").count > 1)
      build( default_os )
    else
      deps

      build( default_os )

      println

      header "Create native class"
      print_wrap "Specify the first native class in the extension, e.g. 'GDTest' or 'GDTest extends Node' etc."
      local type_name = Console.input( "> " )
      if (type_name) type_name .= trimmed
      if (not String.exists(type_name))
        println
        println "[Cancelled]"
        return
      endIf

      local parts = type_name.split(' ')
      parts.modify( $.trimmed )

      if (parts.count == 1)
        rogo_create( type_name, null, null )
      elseIf (parts.count == 2)
        rogo_create( parts[0], parts[1], null )
      else
        rogo_create( parts[0], parts[1], parts[2] )
      endIf

      build( default_os )
    endIf
  else
    header "Create GDExtension framework"
    print_wrap...
      "Enter extension name, e.g. 'gdtest'."
      local name = Console.input( "> " )
      if (name) name .= trimmed
      if (not String.exists(name))
        println
        println "[Cancelled]"
        return
      endIf
    rogo_init( name )
  endIf

  rogo_run
endRoutine

routine rogo_clean
  # Deletes the 'Build' and '.rogo' folders.
  forEach (folder in ["Build",".rogo"])
    local file = File( folder )
    if (file.exists)
      println "[DELETE] $"(folder)
      file.delete
    endIf
  endForEach
endRoutine

routine rogo_init( extension_name:String )
  # Creates the framework for a new GDExtension with the specified name.
  if (not extension_name.count) rogo_help; return

  CreateExtension( extension_name )
endRoutine

# 'rogo help build' custom per-OS description
block builder = String()
  local platforms = supported_platforms
  local architectures = Set<<String>>()
  architectures.[ add("all"), add("default") ]
  architectures.add( forEach in supported_architectures(forEach in platforms) )
  platforms = ["all","default"].[ add(platforms) ]

  builder = ...
    @|Builds the GDExtension for the specified platform(s) and architecture(s).
     |
     |platform:     [$PLATFORMS]
     |architecture: [$ARCHITECTURES]
     |mode:         [all|debug|release]
     |
     |'platform' and/or 'architecture' parts can be omitted, in which case 'default' is assumed.
     |
     |'mode' part can be omitted, in which case 'debug' is assumed.
     |
     |Parts can be specified in any order if unambiguous, e.g. 'debug.x86_64.windows'.
     |
     |'rogo build all' will build all supported platforms and architectures in both release and debug mode.
  builder .= replacing( "$PLATFORMS", platforms.join('|') )
  builder .= replacing( "$ARCHITECTURES", architectures.to_list.join("|") )

  description( "build", builder )
endBlock

routine rogo_build
  # SYNTAX: rogo build [platform.architecture.mode]

  #
  # Builds the GDExtension for the specified platform(s) and architecture(s).
  #
  # platform:     [all|default|android|ios|linux|macos|web|windows]<br>
  # architecture: [all|default|universal|x86_32|x86_64|arm32|arm64|rv64|ppc32|ppc64|wasm32]<br>
  # mode:         [all|debug|release]
  #
  # 'platform' and/or 'architecture' parts can be omitted, in which case 'default' is assumed.
  #
  # 'mode' part can be omitted, in which case 'debug' is assumed.
  #
  # Parts can be specified in any order if unambiguous, e.g. 'debug.x86_64.windows'.
  #
  # 'rogo build all' will build all supported platforms and architectures in both release and debug mode.

  build( System.command_line_arguments.cloned.[remove_first].join('.') )
  # Allow both e.g. 'ios.arm64.debug' and 'ios arm64 debug'.
endRoutine

routine build( target:String )
  local config = BuildConfig( target )

  if (not File("Source").exists)
    throw Error( "Extension must first be created with 'rogo init <extension_name>'." )
  endIf

  deps

  local listing = File( "Source" ).listing( "*.gdextension" )
  local extension_name = which{ listing.count:listing.first || "" }

  local android_ndk_root = System.env//ANDROID_NDK_ROOT
  if (not android_ndk_root)
    local sdk = System.env//ANDROID_HOME
    if (sdk)
      local ndk = File(sdk) / "ndk"
      if (ndk.exists)
        local best = Best<<VersionNumber>>( $1 > $2 )
        best.consider( File(forEach in ndk.listing).filename )
        if (best.exists) android_ndk_root = ndk / best.value
      endIf
    endIf
  endIf

  forEach (platform in config.platforms)
    if (platform == "web")
      patch_js_build
      if (not System.find_executable("em++"))
        throw Error( "[Web] Cannot locate 'em++' compiler. Ensure 'emscripten' is installed." )
      endIf
    elseIf (platform == "android")
      if (not android_ndk_root)
        throw Error( "[NDK] Unable to locate Android NDK. Set ANDROID_NDK_ROOT and retry." )
      endIf
    endIf

    local scons_platform = which{ platform=="web":"javascript" || platform }

    local architectures = config.architectures
    if (architectures.first == "all") architectures = all_architectures( platform )

    forEach (arch in architectures)
      forEach (mode in config.modes)
        header "Building GDExtension $ [$ $ $]"(extension_name,platform,arch,mode)
        local cmd = "scons platform=$ target=template_$"(scons_platform,mode)
        if (arch != "default") cmd .= appending( "arch=$"(arch) )
        if (platform == "android") cmd .= appending( "ANDROID_NDK_ROOT=$"(android_ndk_root) )
        execute cmd
      endForEach
    endForEach

  endForEach

  sync_products
endRoutine

routine patch_js_build
  # Based on https://github.com/godotengine/godot-cpp/issues/1081
  local file = File( "godot-cpp/tools/javascript.py" )
  if (not file.exists) return

  local content = String( file )
  if (content.contains(''#return "EM_CONFIG"'')) return

  header "Patching $ to fix Javascript build"(file)
  local lines = content.split( '\n' )
  local tab = ""
  local rewriter = lines.rewriter
  forEach (line in rewriter)
    if (line.contains(''return "EM_CONFIG"''))
      rewriter.write( line.replacing("return","#return") )
      rewriter.write( line.before_first('r') + "return True" )
    elseIf (line.contains(''if "EM_CONFIG" in os.environ:''))
      tab = line.before_first( "if" )
      rewriter.write( line.replacing("if","#if") )
    elseIf (line.contains(''env["ENV"]''))
      rewriter.write( tab + line.from_first("env") )
      escapeForEach
    else
      rewriter.write( line )
    endIf
  endForEach
  rewriter.write( forEach in rewriter )
  file.save( lines.join('\n') )
endRoutine

routine supported_platforms->String[]
  if (System.is_macos)
    return ["android","ios","macos","web"]
  elseIf (System.is_windows)
    return ["android","web","windows"]
  else
    # Assume Linux
    return ["android","linux","web"]
  endIf
endRoutine

routine supported_architectures( platform:String )->String[]
  which (platform)
    case "android"
      return ["x86_64","arm64"]
    case "ios"
      return ["universal","x86_64","arm64"]
    case "linux"
      return ["x86_64","arm64","rv64"]
    case "macos"
      return ["universal","x86_64","arm64"]
    case "web"
      return ["wasm32"]
    case "windows"
      return ["x86_32","x86_64"]
    others
      throw Error( "[ERROR] Unsupported platform '$'."(platform) )
  endWhich
  return null
endRoutine

routine all_architectures( platform:String )->String[]
  which (platform)
    case "android"
      return ["x86_64","arm64"]
    case "ios"
      return ["universal"]
    case "linux"
      return ["x86_64","arm64","rv64"]
    case "macos"
      return ["universal"]
    case "web"
      return ["wasm32"]
    case "windows"
      return ["x86_32","x86_64"]
    others
      throw Error( "[ERROR] Unsupported platform '$'."(platform) )
  endWhich
  return null
endRoutine

routine default_os->String
  return System.os.to_lowercase
endRoutine

routine rogo_sync( project_filepath:String )
  # Syncs the specified project to be automatically kept up-to-date with this GDExtension's build products.
  # Multiple projects can be synced. Run 'rogo unsync <project_filepath>' to stop updating a project with new builds products.
  if (not String.exists(project_filepath))
    sync_products
    return
  endIf

  local filepaths = String[]
  filepaths.add( forEach in System.command_line_arguments from 1 )

  local outputs = String[]
  local file =  File("LinkedProjects.txt")
  if (file.exists) outputs = String( file ).trimmed.split( '\n' )
  forEach (filepath in filepaths)
    if (not outputs.contains(filepath))
      if (File(filepath).exists and File(filepath/"project.godot").exists)
        outputs.add( filepath )
      elseIf (File(filepath).exists)
        println "[ERROR] $ does not contain a project.godot file - skipping."(filepath)
      else
        println "[ERROR] Filepath '$' does not exist - skipping."(filepath)
      endIf
    endIf
  endForEach
  file.save( outputs.join('\n') + "\n" )

  rogo_sync( null )
endRoutine

routine rogo_unsync( project_filepath:String )
  # Stops updating the specified Godot project with updated builds of this extension.
  local filepaths = String[]
  filepaths.add( forEach in System.command_line_arguments from 1 )

  local outputs = String[]
  local file =  File("LinkedProjects.txt")
  if (file.exists) outputs = String( file ).trimmed.split( '\n' )
  forEach (filepath in filepaths)
    outputs.remove( filepath )
  endForEach
  file.save( outputs.join('\n') )
endRoutine

routine rogo_create( class_name:String, extends:String, base_class_name:String )
  # SYNTAX: rogo create <ClassName> [extends <BaseClassName>]
  # Generates framework code for a native class with the specified name.
  # If no 'extends <BaseClassName>' is specified, the new class will extend 'RefCounted'.
  # Extending 'Node' (or 'Node2D' etc.) will create a node class that can be added to the
  # scene tree. Can be repeated to create multiple native classes as part of this GDExtension.
  if (String.exists(extends))
    contingent
      necessary (extends == "extends" or extends == ":")
      necessary (String.exists(base_class_name))
    unsatisfied
      throw Error( "[ERROR] Syntax error - expected 'rogo create $' or 'rogo create $ extends <BaseClassName>'."(class_name,class_name) )
    endContingent
  else
    base_class_name = "RefCounted"
  endIf
  CreateClass( class_name, base_class_name )
endRoutine

routine sync_products->Logical
  # Copy build products to synched output projects.
  local files = Files( "Source", "*.gdextension" )
  local header_shown = false
  if (files.sync_to(File("Build"), &keep_unused, &dry_run))
    header "Synchronizing build products to linked projects"
    files.sync_to( File("Build"), &verbose, &keep_unused )
    header_shown = true
  endIf

  local outputs = String[]
  local file =  File("LinkedProjects.txt")
  if (file.exists) outputs = String( file ).trimmed.split( '\n' )
  forEach (filepath in outputs)
    if (File(filepath).exists)
      local bin = File( filepath/"bin"  )
      bin.create_folder
      local products = Files( "Build" )
      products.add( "*.gdextension" )
      products.add( "*.dll" )
      products.add( "*.dylib" )
      products.add( "*.framework/**" )
      products.add( "*.so" )
      products.add( "*.wasm" )
      if (products.sync_to(bin,&dry_run,&keep_unused))
        if (not header_shown)
          header "Synchronizing build products to linked projects"
          header_shown = true
        endIf
        products.sync_to( bin, &verbose, &keep_unused )
      endIf
    endIf
  endForEach

  if (not header_shown) header "Linked projects are up to date"
  return header_shown
endRoutine

routine rogo_run
  # Runs the AUTOLAUNCH project, if defined.
  if (String.exists(Build.AUTOLAUNCH))
    if (System.is_macos)
      local exe = Build.GODOT_EXE_MACOS
      if (String.exists(exe) and not exe.ends_with(".app"))
        local cmd = "$ $/project.godot"(File(Build.GODOT_EXE_MACOS).esc,File(Build.AUTOLAUNCH).esc)
        execute cmd
      else
        local cmd = "open"
        if (String.exists(exe)) cmd .= appending( "-a $"(File(exe).esc) )
        cmd .= appending( "$/project.godot"(File(Build.AUTOLAUNCH).esc) )
        execute cmd
      endIf
    elseIf (System.is_windows)
      if (String.exists(Build.GODOT_EXE_WINDOWS))
        local cmd = "$ $/project.godot"(File(Build.GODOT_EXE_WINDOWS).esc,File(Build.AUTOLAUNCH).esc)
        execute cmd
      endIf
    else
      if (String.exists(Build.GODOT_EXE_LINUX))
        local cmd = "$ $/project.godot"(File(Build.GODOT_EXE_LINUX).esc,File(Build.AUTOLAUNCH).esc)
        execute cmd
      endIf
    endIf
  endIf
endRoutine

routine rogo_deps
  # Installs or updates the 'godot-cpp' dependency repo.
  deps( &check_for_update )
endRoutine

routine deps( &check_for_update )
  if (not File("godot-cpp").exists)
    header "Cloning godot-cpp repo"
    execute "git clone -b $ https://github.com/godotengine/godot-cpp.git"(Build.GODOT_CPP_BRANCH)
  elseIf (check_for_update)
    header "Updating godot-cpp repo"
    execute "(cd godot-cpp && git pull)"
  endIf

  local patcher = GitIgnorePatcher( ".gitignore" )

  patcher.add( "# GDExtension", "/godot-cpp" )

  patcher.add( "# Rogo", ".rogo" )
  patcher.add( "# Rogo", "/Build" )
  patcher.add( "# Rogo", "BuildLocal.rogue" )
  patcher.add( "# Rogo", "/LinkedProjects.txt" )
  patcher.add( "# Rogo", "Local.rogo" )

  patcher.add( "# SCons", ".sconsign.dblite" )

  patcher.add( "# Vim", "*.swo" )
  patcher.add( "# Vim", "*.swp" )

  if (patcher.is_modified)
    if (patcher.file.exists) header "Updating .gitignore"
    else                     header "Creating .gitignore"
    patcher.print_new_entries
    patcher.save
  endIf
endRoutine

routine execute( commands:String, error_message=null:String, &suppress_error )->Logical
  forEach (cmd in LineReader(commands))
    print( "> " )
    println( cmd )
    if (0 != System.run(cmd))
      if (suppress_error)
        return false
      else
        if (not error_message) error_message = "Build failed."
        throw Error( error_message )
      endIf
    endIf
  endForEach
  return true
endRoutine

class BuildConfig
  GLOBAL PROPERTIES
    PLATFORMS        = ["all","default","android","ios","javascript","js","linux","macos","web","windows"]
    ARCHITECTURES    = ["all","default","universal","x86_32","x86_64","arm32","arm64","rv64","ppc32","ppc64","wasm32"]
    MODES            = ["debug","release"]

  PROPERTIES
    platforms = String[]
    architectures = String[]
    modes = String[]

  METHODS
    method init( target_string:String )
      if (not String.exists(target_string)) target_string = "default"

      local targets = target_string.split('.')

      local mode = targets.remove_first( BuildConfig.MODES.contains($) )
      local platform = targets.remove_first( BuildConfig.PLATFORMS.contains($) )
      local architecture = targets.remove_first( BuildConfig.ARCHITECTURES.contains($) )

      if (platform == "javascript" or platform == "web") platform = "web"
      if (not mode) mode = targets.remove_first( $ == "all" )

      if (not targets.is_empty)
        throw Error( "[ERROR] Invalid target '$'."(targets.first) )
      endIf

      localize supported_platforms

      if (not platform or platform == "default") platform = default_os

      if (platform == "all")
        platforms.add( supported_platforms )
        if (not architecture) architecture = "all"
      else
        platforms.add( platform )
        if (not supported_platforms.contains(platform))
          throw Error( "Invalid platform target '$'. Valid platforms on $ are [$]."...
                       (platform,System.os,supported_platforms.join("|")) )
        endIf
        if (not architecture) architecture = "default"
      endIf

      if (platform == "all")
        if (architecture == "all" or architecture == "default")
          architectures.add( architecture )
        else
          forEach (p in platforms)
            if (not supported_architectures(p).contains(architecture))
              throw Error( "[ERROR] Platform '$' does not support architecture '$'."(p,architecture) )
            endIf
          endForEach
        endIf
      else
        # Specific platform
        if (architecture == "all")
          architectures.add( all_architectures(platform) )
        else
          if (architecture != "default" and not supported_architectures(platform).contains(architecture))
            throw Error( "[ERROR] Platform '$' does not support architecture '$'."(platform,architecture) )
          endIf
          architectures.add( architecture )
        endIf
      endIf

      if (mode)
        if (mode == "all") modes.[ add("debug"), add("release") ]
        else               modes.add( mode )
      else
        if (platform == "all" or architecture == "all")
          modes.[ add("debug"), add("release") ]
        else
          modes.add( "debug" )
        endIf
      endIf

endClass

class CreateExtension
  PROPERTIES
    libname : String

  METHODS
    method init( libname )
      if (File("Source").exists) throw Error( "GDExtension source code already exists. Run 'rogo' to build." )

      File( "Build" ).create_folder
      File( "Source" ).create_folder

      local register_types_cpp =
        @|#include <gdextension_interface.h>
         |#include <godot_cpp/core/class_db.hpp>
         |#include <godot_cpp/core/defs.hpp>
         |#include <godot_cpp/godot.hpp>
         |#include <godot_cpp/variant/utility_functions.hpp>
         |
         |using namespace godot;
         |
         |void initialize_<LIBNAME>_types(ModuleInitializationLevel p_level)
         |{
         |  // --- Initialization levels ---
         |  // MODULE_INITIALIZATION_LEVEL_CORE
         |  // MODULE_INITIALIZATION_LEVEL_SERVERS
         |  // MODULE_INITIALIZATION_LEVEL_SCENE
         |  // MODULE_INITIALIZATION_LEVEL_EDITOR
         |  godot::UtilityFunctions::print( "[<LIBNAME>] Initializing (", p_level, ")" );
         |
         |  if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE)
         |  {
         |    return;
         |  }
         |
         |  // ClassDB::register_class<ClassName>();
         |}
         |
         |void uninitialize_<LIBNAME>_types(ModuleInitializationLevel p_level)
         |{
         |  if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE)
         |  {
         |    return;
         |  }
         |}
         |
         |extern "C"
         |{
         |  GDExtensionBool GDE_EXPORT <LIBNAME>_library_init(
         |    GDExtensionInterfaceGetProcAddress p_get_proc_address,
         |    const GDExtensionClassLibraryPtr p_library,
         |    GDExtensionInitialization *r_initialization )
         |  {
         |    GDExtensionBinding::InitObject init_obj(p_get_proc_address, p_library, r_initialization);
         |
         |    init_obj.register_initializer(initialize_<LIBNAME>_types);
         |    init_obj.register_terminator(uninitialize_<LIBNAME>_types);
         |    init_obj.set_minimum_library_initialization_level(MODULE_INITIALIZATION_LEVEL_SCENE);
         |
         |    return init_obj.init();
         |  }
         |}
      save( register_types_cpp, File("Source/register_types.cpp") )

      local sconstruct =
        @|#!/usr/bin/env python
         |import os
         |import sys
         |
         |env = SConscript("godot-cpp/SConstruct")
         |
         |# For the reference:
         |# - CCFLAGS are compilation flags shared between C and C++
         |# - CFLAGS are for C-specific compilation flags
         |# - CXXFLAGS are for C++-specific compilation flags
         |# - CPPFLAGS are for pre-processor flags
         |# - CPPDEFINES are for pre-processor defines
         |# - LINKFLAGS are for linking flags
         |
         |def add_sources(sources, dir, extension):
         |  for f in os.listdir(dir):
         |    if f.endswith("." + extension):
         |      sources.append(dir + "/" + f)
         |
         |env.Append(CPPPATH=["Source/"])
         |sources = Glob("Source/*.cpp")
         |
         |if env["platform"] == "macos":
         |  add_sources(sources, "Source", "m")
         |  add_sources(sources, "Source", "mm")
         |
         |  # Example - uncomment and adjust as desired
         |  #env.Append(
         |  #    LINKFLAGS=[
         |  #        "-framework",
         |  #        "Foundation"
         |  #    ]
         |  #)
         |
         |  library = env.SharedLibrary(
         |    "Build/lib<LIBNAME>.{}.{}.framework/lib<LIBNAME>.{}.{}".format(
         |      env["platform"], env["target"], env["platform"], env["target"]
         |    ),
         |    source=sources,
         |  )
         |
         |else:
         |  if env["platform"] == "ios":
         |    add_sources(sources, "Source", "m")
         |    add_sources(sources, "Source", "mm")
         |
         |    # Example - uncomment and adjust as desired
         |    #env.Append(
         |    #    LINKFLAGS=[
         |    #        "-framework",
         |    #        "Foundation"
         |    #    ]
         |    #)
         |
         |  library = env.SharedLibrary(
         |    "Build/lib<LIBNAME>{}{}".format(env["suffix"], env["SHLIBSUFFIX"]),
         |    source=sources,
         |  )
         |
         |Default(library)
      save( sconstruct, File("SConstruct") )

      local extension =
        @|[configuration]
         |
         |entry_symbol = "<LIBNAME>_library_init"
         |compatibility_minimum = 4.1
         |
         |[libraries]
         |
         |android.arm64.debug       = "res://bin/lib<LIBNAME>.android.template_debug.arm64.so"
         |android.arm64.release     = "res://bin/lib<LIBNAME>.android.template_release.arm64.so"
         |android.x86_64.debug      = "res://bin/lib<LIBNAME>.android.template_debug.x86_64.so"
         |android.x86_64.release    = "res://bin/lib<LIBNAME>.android.template_release.x86_64.so"
         |ios.debug                 = "res://bin/lib<LIBNAME>.ios.template_debug.universal.dylib"
         |ios.release               = "res://bin/lib<LIBNAME>.ios.template_release.universal.dylib"
         |javascript.wasm32.debug   = "lib<LIBNAME>.javascript.template_debug.wasm32.wasm"
         |javascript.wasm32.release = "lib<LIBNAME>.javascript.template_release.wasm32.wasm"
         |linux.arm64.debug         = "res://bin/lib<LIBNAME>.linux.template_debug.arm64.so"
         |linux.arm64.release       = "res://bin/lib<LIBNAME>.linux.template_release.arm64.so"
         |linux.rv64.debug          = "res://bin/lib<LIBNAME>.linux.template_debug.rv64.so"
         |linux.rv64.release        = "res://bin/lib<LIBNAME>.linux.template_release.rv64.so"
         |linux.x86_32.debug        = "res://bin/lib<LIBNAME>.linux.template_debug.x86_32.so"
         |linux.x86_32.release      = "res://bin/lib<LIBNAME>.linux.template_release.x86_32.so"
         |linux.x86_64.debug        = "res://bin/lib<LIBNAME>.linux.template_debug.x86_64.so"
         |linux.x86_64.release      = "res://bin/lib<LIBNAME>.linux.template_release.x86_64.so"
         |macos.debug               = "res://bin/lib<LIBNAME>.macos.template_debug.framework"
         |macos.release             = "res://bin/lib<LIBNAME>.macos.template_release.framework"
         |windows.x86_32.debug      = "res://bin/lib<LIBNAME>.windows.template_debug.x86_32.dll"
         |windows.x86_32.release    = "res://bin/lib<LIBNAME>.windows.template_release.x86_32.dll"
         |windows.x86_64.debug      = "res://bin/lib<LIBNAME>.windows.template_debug.x86_64.dll"
         |windows.x86_64.release    = "res://bin/lib<LIBNAME>.windows.template_release.x86_64.dll"
      save( extension, File("Source/$.gdextension"(libname)) )

      header "Extension '$' created."(libname)
      println

      rogo_default

      header "Finished! Run 'rogo help' to list available build commands."

    method save( source:String, file:File )
      if (file.exists) return
      println "  [CREATE] $"(file)
      source .= replacing( "<LIBNAME>", libname )
      file.save( source )
endClass

class CreateClass
  PROPERTIES
    name              : String
    name_uc           : String
    base_class_name   : String
    base_class_header : String

  METHODS
    method init( name, base_class_name )
      deps

      name_uc = name.to_uppercase

      header "Creating native class $ extends $"(name,base_class_name)

      # Find header for base class
      if (base_class_name == "RefCounted")
        base_class_header = "#include <godot_cpp/classes/ref.hpp>"
      else
        contingent
          local base_lc = base_class_name.to_lowercase
          forEach (filepath in Files("godot-cpp/gen/include","godot_cpp/classes/**/*.hpp"))
            if (base_lc == File(filepath).filename.to_lowercase.replacing("_","").before_last(".hpp"))
              base_class_header = "#include <$>"(filepath.after_first("godot-cpp/gen/include/"))
              sufficient (true)
            endIf
          endForEach

          forEach (filepath in Files("Source","*.h"))
            if (base_lc == File(filepath).filename.to_lowercase.replacing("_","").before_last(".h"))
              base_class_header = ''#include "$"''(filepath.after_first("Source/"))
              sufficient (true)
            endIf
          endForEach

          header "Cannot determine appropriate header for base class '$'. "(base_class_name) +
                 "Manually add appropriate #include in '$.h'."(name)
          base_class_header = ""
        endContingent
      endIf

      local h =
        @|#ifndef <NAME_UC>_H
         |#define <NAME_UC>_H
         |
         |#ifdef WIN32
         |  #include <windows.h>
         |#endif
         |
         |<BASE_CLASS_HEADER>
         |
         |using namespace godot;
         |
         |class <NAME> : public <BASE_CLASS_NAME>
         |{
         |  GDCLASS( <NAME>, <BASE_CLASS_NAME> );
         |
         |  protected:
         |    static void _bind_methods();
         |
         |  public:
         |    // PROPERTIES
         |    Vector2 example_property = Vector2(0,0);
         |
         |    // CONSTRUCTOR METHODS
         |    <NAME>();
         |    ~<NAME>();
         |
         |    // PROPERTY ACCESS METHODS
         |    Vector2 get_example_property();
         |    void    set_example_property( Vector2 value );
         |
         |    // GENERAL METHODS
         |    int example_method( int parameter );
         |};
         |
         |#endif // <NAME_UC>_H
      save( h, File("Source/$.h"(name)) )

      local cpp =
        @|#include "<NAME>.h"
         |#include <godot_cpp/core/class_db.hpp>
         |
         |using namespace godot;
         |
         |<NAME>::<NAME>()
         |{
         |}
         |
         |<NAME>::~<NAME>()
         |{
         |}
         |
         |Vector2 <NAME>::get_example_property()
         |{
         |  return example_property;
         |}
         |
         |void <NAME>::set_example_property( Vector2 value )
         |{
         |  example_property = value;
         |}
         |
         |int <NAME>::example_method( int parameter )
         |{
         |  return parameter + 1;
         |}
         |
         |void <NAME>::_bind_methods()
         |{
         |  ClassDB::bind_method( D_METHOD("get_example_property" ),         &<NAME>::get_example_property );
         |  ClassDB::bind_method( D_METHOD("set_example_property", "value"), &<NAME>::set_example_property );
         |  ClassDB::bind_method( D_METHOD("example_method", "parameter"),   &<NAME>::example_method, DEFVAL(1) );
         |  ADD_PROPERTY( PropertyInfo(Variant::VECTOR2,"example_property"), "set_example_property", "get_example_property" );
         |}
      save( cpp, File("Source/$.cpp"(name)) )

      patch_register_types_cpp

    method patch_register_types_cpp
      local file = File( "Source/register_types.cpp" )
      local content = String( file )
      local lines = content.split( '\n' )

      local new_line = "ClassDB::register_class<$>();"(name)
      if ((forEach in lines).contains(new_line)) return

      println "  [PATCH]  Source/register_types.cpp"
      local index = lines.locate_last( $.contains("::register_class") )
      if (index)
        index = index.value + 1
      else
        index = lines.locate( $.begins_with('}') )
      endIf
      lines.insert( "  $"(new_line), &before_index=index.value )

      index = lines.locate_last( $.begins_with("#include") )
      lines.insert( ''#include "$.h"''(name), &before_index=index.value+1 )

      file.save( lines.join('\n') )

    method save( source:String, file:File )
      if (file.exists) return
      println "  [CREATE] $"(file)
      source .= replacing( "<NAME>", name )
      source .= replacing( "<NAME_UC>", name_uc )
      source .= replacing( "<BASE_CLASS_HEADER>", base_class_header )
      source .= replacing( "<BASE_CLASS_NAME>", base_class_name )
      file.save( source )

endClass

routine header( content:String )
  local n = Console.width.or_smaller(100)
  content .= word_wrapped( n-2 )

  println "┌$┐" ("─"*(n-2))
  forEach (line in content.split('\n'))
    println "│$$│"(line," "*(n-(line.count+2)))
  endForEach
  println "└$┘" ("─"*(n-2))
endRoutine

routine print_wrap( text:String )
  println text.word_wrapped( 100.or_smaller(Console.width) )
endRoutine

#-------------------------------------------------------------------------------
# Introspection-based Launcher Framework
#-------------------------------------------------------------------------------
# Rogo is a "build your own build system" facilitator. At its core Rogo just
# recompiles build files if needed and then runs the build executable while
# forwarding any command line arguments. This file contains a default framework
# which uses introspection to turn command line arguments into parameterized
# routine calls.

# Example: to handle the command "rogo abc xyz 5", define
# "routine rogo_abc_xyz( n:Int32 )".

# "rogo_default" will run in the absence of any other command line argument.

# The following "comment directives" can be used in this file to control how
# RogueC compiles it and to manage automatic dependency installation and
# linking.

# Each of the following should be on a line beginning with the characters #$
# (preceding whitespace is fine). Sample args are given.

#   ROGUEC       = roguec       # Path to roguec to compile this file with
#   ROGUEC_ARGS  = --whatever   # Additional options to pass to RogueC
#   CC           = gcc -Wall -fno-strict-aliasing
#   CC_ARGS      = -a -b -c          # Additional C args
#   LINK         = -lalpha -lbeta    # Link this build file with these options
#   LINK(macOS)  = ...               # Options applying only to
#                                    # System.os=="macOS" (use with any OS and
#                                    # any comment directive)
#   LINK_LIBS    = true              # Links following LIBRARIES with this Build
#                                    # file (otherwise just installs them)
#   LINK_LIBS    = false             # Linking turned off for following
#                                    # LIBRARIES - info can still be obtained
#                                    # from $LIBRARY_FLAGS or $LIBRARIES(libname,...)
#   LIBRARIES    = libalpha
#   LIBRARIES    = libbeta(library-name)
#   LIBRARIES    = libfreetype6-dev(freetype2)
#   DEPENDENCIES = Library/Rogue/**/*.rogue
#
#   LIBRARIES    = name(package)
#   LIBRARIES    = name(
#                    exe:<which-name>
#                    exists-cmd:<exists-cmd>
#                    flags:<library-flags>
#                    ignore-exe-only:<setting>
#                    info:<info-name>
#                    info-cmd:<get-info-cmd>
#                    install:<install-name>
#                    install-cmd:<install-cmd>
#                    link:<setting>
#                    package:<package-name>
#                  )
#
# The following macro is replaced within this file (Build.rogue) - the libraries
# should normally also be declared in #$ LIBRARIES:
#
#   $LIBRARY_FLAGS(lib1,lib2)                              # sample macro
#     ->
#   -Ipath/to/lib1/include -Lpath/to/lib1/library -I ...   # sample replacement

routine syntax( command:String, text:String )
  Build.rogo_syntax[ command ] = text
endRoutine

routine description( command:String, text:String )
  Build.rogo_descriptions[ command ] = text
endRoutine

routine help( command:String, description_text=null:String, syntax_text=null:String )
  if (description_text) description( command, description_text )
  if (syntax_text)      syntax( command, syntax_text )
endRoutine

try
  Build.launch
catch (err:Error)
  Build.rogo_error = err
  Build.on_error
endTry

class Build [singleton]
  PROPERTIES
    rogo_syntax         = [String:String]
    rogo_descriptions   = [String:String]
    rogo_prefix         = "rogo_"
    rogo_command        = "default"
    rogo_args           = @[]
    rogo_error          : Error

    LOCAL_SETTINGS_FILE = "Local.rogo"

  METHODS
    method launch
      rogo_args.add( forEach in System.command_line_arguments )
      read_defs
      on_launch
      parse_args
      dispatch_command

    method dispatch_command
      local m = find_command( rogo_command )
      if (not m) throw Error( "No such routine rogo_$()" (rogo_command) )

      local args = @[]
      forEach (arg in rogo_args)
        which (arg)
          case "true":  args.add( true )
          case "false": args.add( false )
          case "null":  args.add( null )
          others:       args.add( arg )
        endWhich
      endForEach
      m( args )

    method find_command( name:String )->MethodInfo
      return <<Routine>>.find_global_method( rogo_prefix + name )

    method on_error
      local w = Console.width.or_smaller( 80 )
      Console.error.println "=" * w
      Console.error.println rogo_error->String.word_wrapped(w)
      Console.error.println "=" * w
      on_exit
      System.exit 1

    method on_command_found
      noAction

    method on_command_not_found
      local w = Console.width.or_smaller( 80 )
      println "=" * w
      println "ERROR: No such command '$'." (rogo_args.first)
      println "=" * w
      println
      rogo_command = "help"
      rogo_args.clear
      on_command_found

    method on_launch
      noAction

    method on_exit
      noAction

    method parse_args
      block
        if (rogo_args.count)
          local parts = String[]
          parts.add( forEach in rogo_args )
          rogo_args.clear

          while (parts.count)
            local cmd = parts.join("_")
            if (find_command(cmd))
              rogo_command = cmd
              on_command_found
              escapeBlock
            endIf
            rogo_args.insert( parts.remove_last )
          endWhile

          on_command_not_found
        endIf

        # Use default command
        on_command_found
      endBlock

    method read_defs
      read_defs( LOCAL_SETTINGS_FILE )

    method read_defs( defs_filepath:String )
      # Attempt to read defs from Local.rogo
      local overrides = String[]
      if (File(defs_filepath).exists)
        forEach (line in LineReader(File(defs_filepath)))
          if (line.contains("="))
            local name  = line.before_first('=').trimmed
            local value = line.after_first('=').trimmed
            if (value.begins_with('"') or value.begins_with('\''))
              value = value.leftmost(-1).rightmost(-1)
            endIf
            local p = <<Build>>.find_property( name )
            if (p)
              overrides.add( "$ = $" (name,value) )
              p.set_value( this, value )
            endIf
          endIf
        endForEach
      endIf

    method _join( value:Value )->String
      local args = String[]
      args.add( forEach in value )
      return args.join( "_" )
endClass


routine rogo_help( command="":String )
  # SYNTAX: rogo help [command]
  # Displays help for a specified command or else all build commands.
  command = Build._join( Build.rogo_args )
  if (command.count)
    local syntax = get_syntax( command )
    local success = false
    if (syntax)
      println "SYNTAX"
      println "  " + syntax
      println
      success = true
    endIf
    local description = get_description( command )
    if (description)
      description .= replacing("<br>","\n")
      local max_w = Console.width - 2
      println "DESCRIPTION"
      forEach (line in LineReader(description.word_wrapped(max_w)))
        print( "  " )
        println( line )
      endForEach
      println
      success = true
    endIf
    if (success)
      return
    else
      local w = Console.width.or_smaller( 80 )
      println "=" * w
      println "ERROR: No such command '$'." (command)
      println "=" * w
      println
    endIf
  endIf

  println "USAGE"
  local entries = CommandInfo[]
  local max_len = 0
  forEach (m in <<Routine>>.global_methods)
    if (m.name.begins_with(Build.rogo_prefix))
      local name = m.name.after_first( Build.rogo_prefix )
      local entry = CommandInfo( name, get_syntax(name), get_description(name) )
      max_len .= or_larger( entry.syntax.count )
      entries.add entry
    endIf
  endForEach

  entries.sort( $1.name < $2.name )
  max_len += 2

  local max_w = Console.width
  forEach (entry in entries)
    print "  " + entry.syntax
    if (entry.@description)
      local description = entry.@description.before_first( '\n' )
      loop (max_len - entry.syntax.count) print ' '
      contingent
        sufficient (2 + max_len + description.count <= max_w)
        if (description.contains(". "))
          description = description.before_first( ". " ) + "."
          sufficient (max_len + description.count <= max_w)
        endIf
        necessary (max_len + 10 <= max_w)
        description = description.unright( (description.count - (max_w - max_len))+5 ) + "..."
      satisfied
        print description
      endContingent
    endIf
    println
  endForEach
  println
endRoutine

routine get_syntax( m_name:String )->String
  if (Build.rogo_syntax.contains(m_name))
    return "rogo " + Build.rogo_syntax[ m_name ]
  else
    local m = <<Routine>>.find_global_method( Build.rogo_prefix + m_name )
    if (not m) return null
    local line = "rogo $" (m_name.replacing('_',' '))
    line += " <$>" ((forEach in m.parameters).name)
    return line
  endIf
endRoutine


routine get_description( m_name:String )->String
  if (Build.rogo_descriptions.contains(m_name))
    return Build.rogo_descriptions[ m_name ]
  else
    return null
  endIf
endRoutine

class CommandInfo( name:String, syntax:String, description:String );
