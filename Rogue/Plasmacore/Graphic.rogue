module Plasmacore

class Graphic [essential]
  GLOBAL PROPERTIES
    singletons = [String:Graphic]
    clonables  = [String:Graphic]

  PROPERTIES
    node      : GDObject

    draw_list : GDObject[]
    draw_pool : GDObject[]

    position : XYZ
    scale    = XYZ(1,1,1)
    rotation : XYZ

    base_size  = XYZ(1,1,1)
    base_scale = XYZ(1,1,1)

    is_active    : Logical
    is_presented : Logical

  GLOBAL METHODS
    method create( name:String )->Graphic
      local entry = singletons.find( name )
      if (entry) return entry.value

      entry = clonables.find( name )
      if (entry) return entry.value.cloned

      if (name.begins_with("res://"))
        local result = Graphic( GDObject.load_scene("res://Assets/Tiles/Wall.tscn") )
        clonables[ name ] = result
        Plasmacore.gd_graphics.add( result.node )
        return result

      else
        local node : GDObject

        contingent
          if (Plasmacore.gd_assets_graphics) node = Plasmacore.gd_assets_graphics[name]
          sufficient (node)

          if (Plasmacore.gd_assets) node = Plasmacore.gd_assets[name]
          necessary (node)

        satisfied
          block
            local result = Graphic( node )
            clonables[ name ] = result
            Plasmacore.gd_graphics.add( node )
            return result
          endBlock

        unsatisfied
          node = Plasmacore.gd_scene[name]
          if (node)
            local result = Graphic( node )
            singletons[ name ] = result
            return result
          endIf

        endContingent

        return Graphic( node )  # undefined graphic
      endIf

  METHODS
    method init( node )
      if (node)
        base_size = find_base_size
      endIf

    method init( existing:Graphic )
      this.node = existing.node.cloned.[ visible=false ]
      this.@position = existing.position
      this.@scale = existing.scale
      this.@rotation = existing.rotation
      this.base_size = existing.base_size
      this.base_scale = existing.base_scale
      existing.node.parent.add( this.node )

    method cloned->Graphic
      return Graphic( this )

    method on_cleanup
      delete

    method add( child:Graphic )
      node.add( child.node )
      if (is_visible) child.is_visible = true

    method find_base_size->XYZ
      if (node.has_method("get_size"))
        local size = node( "get_size" )
        if (size.is_xyz) return size
        else             return XYZ( size->XY, 1 )
      endIf

      if (node.has_meta("size"))
        local size = node.meta( "size" )
        if (size.is_xyz) return size
        else             return XYZ( size->XY, 1 )
      endIf

      if local frames = node.sprite_frames
        if local frame = frames.texture("",0)
          return XYZ( frame.size, 1 )
        endIf
      endIf

      return XYZ(1,1,1)

    method delete
      if (node)
        if (node.parent)
          node.parent.remove( node )
        endIf
        node.delete
        node = GDObject()
      endIf

    method draw( position:XY, rotation=Radians(0):Radians, scale=XY(1,1):XY )
      local copy : GDObject

      if (draw_pool and draw_pool.count)
        copy = draw_pool.remove_last
      else
        copy = node.cloned( node.parent )
        copy.visible = true
      endIf

      if (Plasmacore.is_2dx)
        copy.position = XYZ( position.x, Display.size.y - position.y )
      else
        copy.position = position
      endIf

      copy.scale = base_scale * XYZ(scale,1)
      copy.rotation = XYZ( this.rotation->XY, rotation.value )

      if (Plasmacore.is_2d)
        copy.z_index = next_z_index
        ++next_z_index
      endIf

      if (not draw_list)
        ensure<<draw_list>>
        ensure<<draw_pool>>
        Plasmacore.active_drawing.add( this )
      endIf
      draw_list.add( copy )

    method get( name:String )->Graphic
      return Graphic( node[name] )

    method is_visible->Logical
      return node.is_visible

    method on_update_draw_list_begin
      draw_pool.add( draw_list )
      draw_list.clear

    method on_update_draw_list_end->Logical
      # Returns 'true' if still active
      forEach (node in draw_pool)
        # Delete nodes left unused this cycle
        node.visible = false
        node.delete
      endForEach

      if (draw_list.count) return true

      draw_list = null
      draw_pool = null
      return false

    method place
      if (Plasmacore.is_2d)
        node.z_index = next_z_index
        ++next_z_index
      endIf

      is_visible = true

    method present
      if (not is_active)
        Plasmacore.active_graphics.add( this )
        is_active = true
      endIf

      place

      is_presented = true

    method present( position )
      present

    method set_bounds( box:Box )
      position = box.center
      size = box.size

    method set_is_visible( setting:Logical )
      node.visible = setting

    method set_base_size( @base_size )

    method set_base_size( xy:XY )
      @base_size = XYZ( xy, 1 )

    method set_position( xy:XY )
      @position = XYZ( xy, position.z )
      if (Plasmacore.is_2dx)
        node.position = XYZ( xy.x, Display.size.y - xy.y, position.z )
      else
        node.position = xy
      endIf

    method set_position( xyz:XYZ )
      @position = xyz
      if (Plasmacore.is_2dx)
        node.position = XYZ( xyz.x, Display.size.y - xyz.y, xyz.z )
      else
        node.position = xyz
      endIf

    method set_rotation( z:Radians )
      if (Plasmacore.is_2d) rotation = z
      else                  rotation = XYZ( 0, 0, z )

    method set_rotation( @rotation )
      node.rotation = rotation

    method set_scale( s:Real64 )
      if (Plasmacore.is_2d) scale = XY( s, s )
      else                  scale = XYZ( s, s, s )

    method set_scale( xy:XY )
      @scale = XYZ( xy, scale.z )
      node.scale = (base_scale * scale)->XY

    method set_scale( @scale )
      node.scale = base_scale * scale

    method set_size( sz:Real64 )
      base_scale = XYZ(sz,sz,sz) / base_size

    method set_size( xy:IntXY )
      base_scale = XYZ(xy->XY,1) / base_size

    method set_size( xy:XY )
      base_scale = XYZ(xy,1) / base_size

    method set_size( xyz:XYZ )
      base_scale = xyz / base_size

    method to->String
      if (node) return node.name
      return "(Undefined Graphic)"

  GLOBAL PROPERTIES
    next_z_index : Int32

    active_graphics = Graphic[]
    # When an inactive (untracked) graphic is first presented it marks itself active and presented,
    # makes itself visible, and adds itself to this list.
    #
    # At the beginning of each update, all active_graphics are marked as not presented.
    #
    # Previously-active graphics that present again simply mark themselves as presented.
    #
    # At the end of each update, all active_graphics that have not been presented are marked
    # inactive, made invisible, and removed from the active_graphics list.

    active_drawing = Graphic[]

  GLOBAL METHODS
    method on_update_begin
      (forEach in active_graphics).is_presented = false
      (forEach in active_drawing).on_update_draw_list_begin

    method on_update_end
      forEach (graphic in rewriter=active_graphics.rewriter)
        if (graphic.is_presented)
          # Keep in the active list
          rewriter.write( graphic )
        else
          # Remove from the active list
          graphic.is_active = false
          graphic.is_visible = false
        endIf
      endForEach

      forEach (graphic in rewriter=active_drawing.rewriter)
        if (graphic.on_update_draw_list_end) rewriter.write( graphic )
      endForEach

endClass
